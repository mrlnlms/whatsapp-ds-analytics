---
title: "Data Profiling: WhatsApp Export"
subtitle: "Investiga√ß√£o sistem√°tica da estrutura do arquivo bruto"
author: "Marlon"
date: today
jupyter: whatsapp-ds
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    theme: cosmo
execute:
  warning: false
  echo: true
---

```{python}
#| label: setup
#| code-fold: false

import sys
from dotenv import load_dotenv
import os

# Carrega .env e adiciona src ao path
load_dotenv()
sys.path.insert(0, os.getenv('PROJECT_ROOT') + '/src')

from config import PROJECT_ROOT, PATHS
from profiling import get_file_overview, get_lines_at_position, get_lines_containing, get_lines_matching, count_pattern
import pandas as pd

RAW_FILE = PATHS['raw']

print(f"üìÅ Projeto: {PROJECT_ROOT}")
print(f"üìÑ Arquivo: {RAW_FILE}")
print(f"‚úÖ Existe: {RAW_FILE.exists()}")
```

# Introdu√ß√£o

**Data Profiling** √© a primeira etapa de qualquer projeto de dados: investigar sistematicamente o arquivo bruto para entender sua estrutura, padr√µes e anomalias ‚Äî *antes* de limpar ou transformar qualquer coisa.

Este documento registra as descobertas sobre o formato de exporta√ß√£o do WhatsApp, servindo como refer√™ncia para as decis√µes de limpeza e parsing implementadas nas etapas seguintes.

---

# Vis√£o Geral do Arquivo

## Metadados B√°sicos

```{python}
#| label: file-metadata

from profiling import get_file_overview

get_file_overview(RAW_FILE)
```

## Amostra do Conte√∫do

```{python}
#| label: content-sample

# Primeiras linhas
print("üìÑ IN√çCIO DO ARQUIVO")
print("=" * 80)
get_lines_at_position(RAW_FILE, position=0, n=5)
```

```{python}
# Meio do arquivo
print("\nüìÑ MEIO DO ARQUIVO (~50%)")
print("=" * 80)
get_lines_at_position(RAW_FILE, position=50, n=5)
```

```{python}
# Final do arquivo
print("\nüìÑ FINAL DO ARQUIVO")
print("=" * 80)
get_lines_at_position(RAW_FILE, position=100, n=5)
```

---

# Elementos Estruturais

## Timestamps

O formato padr√£o de timestamp √© `[DD/MM/YY, HH:MM:SS]`.

```{python}
#| label: timestamp-pattern

# Contagem de linhas com timestamp v√°lido
pattern_timestamp = r'^\[\d{2}/\d{2}/\d{2}, \d{2}:\d{2}:\d{2}\]'
count_pattern(RAW_FILE, pattern_timestamp)
```

::: {.callout-note}
O formato pode variar dependendo das configura√ß√µes regionais do dispositivo que exportou.
:::

---

## Remetentes

Ap√≥s o timestamp, o nome do remetente aparece seguido de dois pontos (`:`).

```{python}
#| label: sender-examples

# Exemplos de diferentes remetentes
get_lines_at_position(RAW_FILE, position=10, n=3)
```

::: {.callout-tip}
Remetentes podem conter **emojis** e **caracteres especiais** (ex: `L√™ üñ§`). O parser precisa considerar isso.
:::

---

## Caractere Invis√≠vel U+200E

O caractere `U+200E` (Left-to-Right Mark) aparece frequentemente no export. √â um caractere de controle de dire√ß√£o de texto.

```{python}
#| label: u200e-analysis

# Quantas ocorr√™ncias existem?
stats_u200e = count_pattern(RAW_FILE, '\u200e')
print(f"üìä Estat√≠sticas do U+200E:")
print(f"   ‚Ä¢ Total de ocorr√™ncias: {stats_u200e['total_ocorrencias']:,}")
print(f"   ‚Ä¢ Linhas afetadas: {stats_u200e['linhas_com_pattern']:,}")
```

```{python}
# Exemplos de onde aparece
print("\nüîç Exemplos de linhas com U+200E:")
get_lines_containing(RAW_FILE, '\u200e', n=5)
```

::: {.callout-warning}
### Decis√£o de Cleaning
Este caractere ser√° **removido** na etapa de limpeza pois:

- N√£o carrega informa√ß√£o sem√¢ntica √∫til
- Complica o parsing com regex
- Representa ~4.6% do tamanho do arquivo
:::

---

## Linhas de Continua√ß√£o

Mensagens longas podem ocupar m√∫ltiplas linhas. Linhas sem timestamp s√£o continua√ß√µes da mensagem anterior.

```{python}
#| label: multiline-examples

# Linhas que N√ÉO come√ßam com timestamp (continua√ß√µes)
pattern_no_timestamp = r'^(?!\[?\d{2}/\d{2}/\d{2})'
count_pattern(RAW_FILE, pattern_no_timestamp)
```

::: {.callout-tip}
### Decis√£o de Wrangling
O parser deve **agregar** linhas de continua√ß√£o ao conte√∫do da mensagem anterior, preservando quebras de linha originais.
:::

---

# Taxonomia de Mensagens

## Mensagens de Texto

### Texto Puro

```{python}
#| label: text-pure

# Mensagens simples (sem m√≠dia, sem marcadores especiais)
get_lines_matching(RAW_FILE, r'\] .+?: [A-Za-z√Ä-√∫]', n=3)
```

### Texto com Emojis

```{python}
#| label: text-emoji

# Mensagens contendo emojis comuns
get_lines_containing(RAW_FILE, 'üòÇ', n=2)
get_lines_containing(RAW_FILE, '‚ù§', n=2)
```

### Texto com Links

```{python}
#| label: text-links

# Mensagens com URLs
get_lines_matching(RAW_FILE, r'https?://', n=3)
```

---

## Mensagens de M√≠dia

### M√≠dias Omitidas

Quando o export n√£o inclui os arquivos de m√≠dia:

```{python}
#| label: media-omitted

tipos_omitidos = ['audio omitted', 'image omitted', 'video omitted', 
                  'sticker omitted', 'GIF omitted', 'document omitted']

print("üìä Contagem de m√≠dias omitidas:\n")
for tipo in tipos_omitidos:
    stats = count_pattern(RAW_FILE, tipo)
    if stats['total_ocorrencias'] > 0:
        print(f"   ‚Ä¢ {tipo}: {stats['total_ocorrencias']:,}")
```

```{python}
# Exemplos
print("\nüîç Exemplos de m√≠dia omitida:")
get_lines_containing(RAW_FILE, 'audio omitted', n=2)
```

### M√≠dias Anexadas

Quando o export inclui os arquivos:

```{python}
#| label: media-attached

# Padr√£o: <attached: FILENAME.ext>
stats_attached = count_pattern(RAW_FILE, r'<attached:')
print(f"üìä M√≠dias anexadas: {stats_attached['total_ocorrencias']:,}")
```

```{python}
# Exemplos por tipo
print("\nüîç Exemplos de m√≠dia anexada:")
get_lines_matching(RAW_FILE, r'<attached:.*\.opus>', n=2)  # √Åudio
get_lines_matching(RAW_FILE, r'<attached:.*\.jpg>', n=2)   # Imagem
get_lines_matching(RAW_FILE, r'<attached:.*\.mp4>', n=2)   # V√≠deo
```

::: {.callout-note}
### Padr√£o de nomenclatura dos arquivos
`N√öMERO-TIPO-DATA-HORA.extens√£o`

Exemplo: `00000001-AUDIO-2025-08-21-21-31-39.opus`
:::

---

## Mensagens Especiais

### Mensagens Editadas

```{python}
#| label: msg-edited

stats_edited = count_pattern(RAW_FILE, r'<This message was edited>')
print(f"üìä Mensagens editadas: {stats_edited['total_ocorrencias']:,}")

get_lines_containing(RAW_FILE, '<This message was edited>', n=2)
```

### Mensagens Deletadas

```{python}
#| label: msg-deleted

stats_deleted = count_pattern(RAW_FILE, r'This message was deleted')
print(f"üìä Mensagens deletadas: {stats_deleted['total_ocorrencias']:,}")

get_lines_containing(RAW_FILE, 'This message was deleted', n=2)
```

### Chamadas de Voz/V√≠deo

```{python}
#| label: msg-calls

stats_calls = count_pattern(RAW_FILE, r'(Missed|Voice|Video) (voice |video )?call')
print(f"üìä Registros de chamadas: {stats_calls['total_ocorrencias']:,}")

get_lines_containing(RAW_FILE, 'call', n=3)
```

---

# Resumo das Descobertas

## Decis√µes para Data Cleaning

| Descoberta | Decis√£o |
|------------|---------|
| Caractere U+200E em ~50% das linhas | Remover todas ocorr√™ncias |
| Timestamps vazios ocasionais | Remover linhas |
| Linhas completamente vazias | Remover |
| Espa√ßos m√∫ltiplos | Normalizar para espa√ßo √∫nico |
| Nomes dos participantes | Anonimizar (P1, P2) |
| Formato timestamp `[DD/MM/YY, HH:MM:SS]` | Simplificar para `DD/MM/YY HH:MM:SS` |

## Decis√µes para Data Wrangling

| Descoberta | Decis√£o |
|------------|---------|
| Linhas de continua√ß√£o (multi-linha) | Agregar ao conte√∫do da mensagem anterior |
| M√≠dias omitidas vs anexadas | Classificar em `status_midia` |
| Arquivos f√≠sicos de m√≠dia | Vincular pelo nome do arquivo |
| √Åudios e v√≠deos anexados | Transcrever via API (Groq/Whisper) |

## Padr√µes Regex Necess√°rios

```python
# Timestamp
r'^\[(\d{2}/\d{2}/\d{2}), (\d{2}:\d{2}:\d{2})\]'

# Mensagem completa (ap√≥s otimiza√ß√£o)
r'^(\d{2}/\d{2}/\d{2}) (\d{2}:\d{2}:\d{2}) (.+?): (.*)$'

# M√≠dia omitida
r'(audio|image|video|sticker|GIF|document) omitted'

# M√≠dia anexada
r'<attached: (.+?)>'
```

---

# Pr√≥ximos Passos

Com o profiling completo, seguimos para:

1. **[Data Cleaning](01-data-cleaning.qmd)** ‚Äî Implementar limpeza
2. **[Data Wrangling](02-data-wrangling.qmd)** ‚Äî Parsing e estrutura√ß√£o