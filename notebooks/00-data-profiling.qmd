---
title: "Discovery & Data Profiling"
subtitle: "InvestigaÃ§Ã£o sistemÃ¡tica da estrutura do arquivo bruto"
author: "Marlon L."
date: today
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    theme: cosmo
execute:
  warning: false
  echo: false
---

```{python}
#| label: setup
#| code-fold: false

import sys
from dotenv import load_dotenv
import os
import pandas as pd
# Carrega .env e adiciona src ao path
load_dotenv()
sys.path.insert(0, os.getenv('PROJECT_ROOT') + '/src')

from config import PROJECT_ROOT, PATHS
from pathlib import Path

from utils.dataframe_helpers import multi_position_preview_dataframe
from utils.file_helpers import get_file_overview

from utils import get_file_overview, format_file_overview_table
from utils import get_file_density_stats, format_density_stats_table
from profiling import get_file_overview, get_lines_at_position, get_lines_containing, get_lines_matching, count_pattern

# Define arquivo raw como variÃ¡vel global do notebook
RAW_FILE = PATHS['raw']
```

# Discovery & Data Profiling

Toda pipeline de dados comeÃ§a com a **investigaÃ§Ã£o do arquivo bruto** antes de qualquer transformaÃ§Ã£o. Este documento registra o processo de descoberta â€” desde a primeira impressÃ£o atÃ© a catalogaÃ§Ã£o sistemÃ¡tica de padrÃµes, anomalias e edge cases que orientarÃ£o as etapas seguintes.

## Discovery

Antes de qualquer processamento, precisamos **entender o que temos em mÃ£os**. O primeiro passo Ã© abrir o arquivo bruto e navegar pelo conteÃºdo â€” observar padrÃµes visuais, testar hipÃ³teses, identificar anomalias. Ã‰ uma fase exploratÃ³ria e livre, onde as primeiras impressÃµes orientam a investigaÃ§Ã£o posterior.

Para comeÃ§ar, vamos extrair os metadados bÃ¡sicos do arquivo: tamanho, nÃºmero de linhas, densidade de caracteres. Essas mÃ©tricas fornecem uma noÃ§Ã£o inicial da escala do desafio.

::: panel-tabset
## VisÃ£o geral da fonte de dados

```{python}
#| label: file-overview
#| output: false
# ObtÃ©m metadados
overview = get_file_overview(RAW_FILE)
# Extrai nome do arquivo
ARQUIVO_NOME = Path(overview['arquivo']).name
```

```{python}
#| label: show-file-overview
#| echo: false
df_overview = format_file_overview_table(overview)
df_overview.style.hide(axis='index')
```

## EstatÃ­sticas de Densidade

```{python}
#| label: density-stats
#| output: false
density = get_file_density_stats(RAW_FILE)
```

```{python}
#| label: show-density-table
#| echo: false

df_density = format_density_stats_table(density)
df_density.style.hide(axis='index')
```
:::

### Overview dos dados

ApÃ³s importar a fonte de dados para a pipeline e extrair os metadados, vamos examinar o conteÃºdo para entender **a natureza dos dados que estamos lidando**. O formato segue uma estrutura semi-estruturada aparentemente simples: `[DD/MM/YY, HH:MM:SS] Remetente: Mensagem`.

![](../assets/images/data-overview_2025-11-21%2010.35.55.gif)

> *Dados brutos exportados do WhatsApp â€” histÃ³rico de \~1 ano visualizado no Positron.*

Ã€ primeira vista a estrutura parece regular, mas a tabela de amostras abaixo revela outros padrÃµes que aumentam a complexidade do parsing.

::: {.callout-note collapse="true"}
#### Amostras do arquivo *`{python} ARQUIVO_NOME`*

```{python}
#| label: sample-data
df = multi_position_preview_dataframe(
    RAW_FILE,
    n_lines=3,
    positions=[0, 25, 50, 75, 100]
)

df.style.hide(axis='index')
```

> *Linhas distribuÃ­das por quartis (0%, 25%, 50%, 75%, 100%) para visualizar padrÃµes ao longo do documento.*
:::

::: {.callout-caution icon="false" collapse="true"}
### ğŸ’¡ Insights Iniciais

**Volume e Complexidade**

-   \~97K linhas, mas apenas \~70K mensagens reais (estimativa: 1,4 linhas/mensagem)
-   Metadados (timestamps, nomes) e linhas vazias (1,2%) ocupam espaÃ§o considerÃ¡vel
-   Para contexto: SMS Spam Collection (referÃªncia em NLP) tem apenas 5,6K mensagens â€” este dataset Ã© **12x maior**

**Densidade e VariaÃ§Ã£o**

-   MÃ©dia de 50 chars/linha, tÃ­pico de mensagens de chat
-   **Alta variaÃ§Ã£o:** 1 a 1.103 caracteres (moda em 45)
-   DiferenÃ§a entre mediana (45) e mÃ©dia (50) indica **outliers** (mensagens muito longas)
-   Importante: boa parte dos caracteres sÃ£o metadados, nÃ£o conteÃºdo de mensagem

**ImplicaÃ§Ãµes para o Pipeline**

-   âœ… Arquivo de 5MB Ã© leve â€” processamento em memÃ³ria viÃ¡vel
-   âš ï¸ TranscriÃ§Ã£o de Ã¡udios/vÃ­deos pode expandir o dataset significativamente
-   ğŸ”§ NecessÃ¡rio separar metadados (timestamp, remetente) do conteÃºdo real
-   ğŸ”§ Parsing deve lidar com mensagens multilinha (detectadas nas amostras)
-   ğŸ”§ Caracteres especiais (emoji no nome "LÃª ğŸ–¤") exigem encoding UTF-8

**PadrÃµes Observados nas Amostras**

-   Mensagens omitidas: `image omitted`, `video note omitted`
-   MÃ­dias anexadas: `<arquivo.opus>`
-   Mensagens multilinha (ex: linha 48667-48669)
-   Linhas vazias entre mensagens
-   URLs compartilhadas
:::

## Data Profiling

ApÃ³s a exploraÃ§Ã£o inicial, chegou o momento de **sistematizar e aprofundar as descobertas**. Enquanto o Discovery ofereceu uma primeira impressÃ£o visual e mÃ©trica, esta etapa vai alÃ©m: investiga **sistematicamente** cada elemento estrutural do arquivo, cataloga **todos os tipos de padrÃµes** (nÃ£o apenas os visÃ­veis Ã  primeira vista), e documenta **edge cases** que podem quebrar parsers ingÃªnuos.

Esta seÃ§Ã£o cria uma referÃªncia tÃ©cnica completa que fundamenta as decisÃµes de limpeza e parsing nas etapas seguintes.

<details style="margin: 0.5em 0; list-style: none; border: 1px solid #d4d4d4; border-radius: 5px; padding: 10px;">

<summary style="font-size: 1.3em; font-weight: 600; color: #343a40; list-style: none;">

â–¸ Elementos Estruturais

</summary>

::: {.callout-note title="Timestamps" icon="false" appearance="simple" collapse="true"}
O formato padrÃ£o de timestamp Ã© `[DD/MM/YY, HH:MM:SS]`.

```{python}
#| label: timestamp-pattern2

# Contagem de linhas com timestamp vÃ¡lido
pattern_timestamp = r'^\[\d{2}/\d{2}/\d{2}, \d{2}:\d{2}:\d{2}\]'
count_pattern(RAW_FILE, pattern_timestamp)
```
:::

::: {.callout-note title="Remententes" icon="false" appearance="simple" collapse="true"}
ApÃ³s o timestamp, o nome do remetente aparece seguido de dois pontos (`:`).

```{python}
#| label: sender-examples

# Exemplos de diferentes remetentes
get_lines_at_position(RAW_FILE, position=10, n=3)
```

> Remetentes podem conter **emojis** e **caracteres especiais** (ex: `LÃª ğŸ–¤`). O parser precisa considerar isso.\
:::

:::: {.callout-note title="Caractere InvisÃ­vel U+200E" icon="false" appearance="simple" collapse="true"}
O caractere `U+200E` (Left-to-Right Mark) aparece frequentemente no export. Ã‰ um caractere de controle de direÃ§Ã£o de texto.

```{python}
#| label: u200e-analysis

# Quantas ocorrÃªncias existem?
stats_u200e = count_pattern(RAW_FILE, '\u200e')
print(f"ğŸ“Š EstatÃ­sticas do U+200E:")
print(f"   â€¢ Total de ocorrÃªncias: {stats_u200e['total_ocorrencias']:,}")
print(f"   â€¢ Linhas afetadas: {stats_u200e['linhas_com_pattern']:,}")
```

```{python}
# Exemplos de onde aparece
print("\nğŸ” Exemplos de linhas com U+200E:")
get_lines_containing(RAW_FILE, '\u200e', n=5)
```

::: callout-warning
### DecisÃ£o de Cleaning

Este caractere serÃ¡ **removido** na etapa de limpeza pois:

-   NÃ£o carrega informaÃ§Ã£o semÃ¢ntica Ãºtil
-   Complica o parsing com regex
-   Representa \~4.6% do tamanho do arquivo
:::

\
::::

</details>

<details style="margin: 0.5em 0; list-style: none; border: 1px solid #d4d4d4; border-radius: 5px; padding: 10px;">

<summary style="font-size: 1.3em; font-weight: 600; color: #343a40; list-style: none;">

â–¸ Taxonomia de Mensagens

</summary>

:::::::: {.callout-note title="Mensagens de Texto" icon="false" appearance="minimal" collapse="true"}
::: {.callout-tip title="Texto Puro" icon="false" appearance="simple" collapse="true"}
```{python}
#| label: text-pure

# Mensagens simples (sem mÃ­dia, sem marcadores especiais)
get_lines_matching(RAW_FILE, r'\] .+?: [A-Za-zÃ€-Ãº]', n=3)
```
:::

::: {.callout-tip title="Texto com Emojis" icon="false" appearance="simple" collapse="true"}
```{python}
#| label: text-emoji

# Mensagens contendo emojis comuns
get_lines_containing(RAW_FILE, 'ğŸ˜‚', n=2)
get_lines_containing(RAW_FILE, 'â¤', n=2)
```
:::

::: {.callout-tip title="Texto com Links" icon="false" appearance="simple" collapse="true"}
```{python}
#| label: text-links

# Mensagens com URLs
get_lines_matching(RAW_FILE, r'https?://', n=3)
```
:::

:::: {.callout-tip title="Linhas de continuaÃ§Ã£o" icon="false" appearance="simple" collapse="true"}
Mensagens longas podem ocupar mÃºltiplas linhas. Linhas sem timestamp sÃ£o continuaÃ§Ãµes da mensagem anterior.

```{python}
#| label: multiline-examples

# Linhas que NÃƒO comeÃ§am com timestamp (continuaÃ§Ãµes)
pattern_no_timestamp = r'^(?!\[?\d{2}/\d{2}/\d{2})'
count_pattern(RAW_FILE, pattern_no_timestamp)
```

::: callout-warning
### DecisÃ£o de Wrangling

O parser deve **agregar** linhas de continuaÃ§Ã£o ao conteÃºdo da mensagem anterior, preservando quebras de linha originais.
:::

\
::::

\
::::::::

:::::: {.callout-note title="Mensagens de MÃ­dia" icon="false" appearance="simple" collapse="true"}
::: {.callout-tip title="MÃ­dias Omitidas" icon="false" appearance="simple" collapse="true"}
Quando o export nÃ£o inclui os arquivos de mÃ­dia:

```{python}
#| label: media-omitted

tipos_omitidos = ['audio omitted', 'image omitted', 'video omitted', 
                  'sticker omitted', 'GIF omitted', 'document omitted']

print("ğŸ“Š Contagem de mÃ­dias omitidas:\n")
for tipo in tipos_omitidos:
    stats = count_pattern(RAW_FILE, tipo)
    if stats['total_ocorrencias'] > 0:
        print(f"   â€¢ {tipo}: {stats['total_ocorrencias']:,}")
```

```{python}
# Exemplos
print("\nğŸ” Exemplos de mÃ­dia omitida:")
get_lines_containing(RAW_FILE, 'audio omitted', n=2)
```
:::

:::: {.callout-tip title="MÃ­dias Anexadas" icon="false" appearance="simple" collapse="true"}
Quando o export inclui os arquivos:

```{python}
#| label: media-attached

# PadrÃ£o: <attached: FILENAME.ext>
stats_attached = count_pattern(RAW_FILE, r'<attached:')
print(f"ğŸ“Š MÃ­dias anexadas: {stats_attached['total_ocorrencias']:,}")
```

```{python}
# Exemplos por tipo
print("\nğŸ” Exemplos de mÃ­dia anexada:")
get_lines_matching(RAW_FILE, r'<attached:.*\.opus>', n=2)  # Ãudio
get_lines_matching(RAW_FILE, r'<attached:.*\.jpg>', n=2)   # Imagem
get_lines_matching(RAW_FILE, r'<attached:.*\.mp4>', n=2)   # VÃ­deo
```

::: callout-warning
### PadrÃ£o de nomenclatura dos arquivos

`NÃšMERO-TIPO-DATA-HORA.extensÃ£o`

Exemplo: `00000001-AUDIO-2025-08-21-21-31-39.opus`
:::
::::

\
::::::

:::::: {.callout-note title="Mensagens Especiais" icon="false" appearance="simple" collapse="true"}
::: {.callout-tip title="Mensagens Editadas" icon="false" appearance="simple" collapse="true"}
```{python}
#| label: msg-edited

stats_edited = count_pattern(RAW_FILE, r'<This message was edited>')
print(f"ğŸ“Š Mensagens editadas: {stats_edited['total_ocorrencias']:,}")

get_lines_containing(RAW_FILE, '<This message was edited>', n=2)
```
:::

::: {.callout-tip title="Mensagens Deletadas" icon="false" appearance="simple" collapse="true"}
```{python}
#| label: msg-deleted

stats_deleted = count_pattern(RAW_FILE, r'This message was deleted')
print(f"ğŸ“Š Mensagens deletadas: {stats_deleted['total_ocorrencias']:,}")

get_lines_containing(RAW_FILE, 'This message was deleted', n=2)
```
:::

::: {.callout-tip title="Chamadas de Voz/VÃ­deo" icon="false" appearance="simple" collapse="true"}
```{python}
#| label: msg-calls

stats_calls = count_pattern(RAW_FILE, r'(Missed|Voice|Video) (voice |video )?call')
print(f"ğŸ“Š Registros de chamadas: {stats_calls['total_ocorrencias']:,}")

get_lines_containing(RAW_FILE, 'call', n=3)
```
:::

\
::::::

</details>

#### **VisÃ£o Consolidada**

ApÃ³s investigar sistematicamente todos os elementos, podemos visualizar a estrutura completa do arquivo:

:::: {.callout-tip icon="false" collapse="true"}
## ğŸŒ² Estrutura do Arquivo WhatsApp Export

::: {style="background: #EFF9EB; padding: 0px; border-radius: 2px; font-family: 'Courier New', monospace; font-size: 0.9em; color: #333; line-height: 1.2;"}
```         
Elementos Estruturais
â”‚
â”œâ”€â”€ Timestamp [DD/MM/YY, HH:MM:SS]
â”œâ”€â”€ Remetente (nome + emoji)
â”œâ”€â”€ Separador (:)
â”œâ”€â”€ ConteÃºdo da mensagem
â””â”€â”€ Caractere invisÃ­vel U+200E (Left-to-Right Mark)

Taxonomia de Mensagens
â”‚
â”œâ”€â”€ Texto
â”‚   â”œâ”€â”€ Puro (texto simples)
â”‚   â”œâ”€â”€ Com Emoji (ğŸ˜‚â¤ï¸ğŸ¥°)
â”‚   â”œâ”€â”€ Com Link (URLs compartilhadas)
â”‚   â””â”€â”€ Multilinha (linhas de continuaÃ§Ã£o)
â”‚
â”œâ”€â”€ MÃ­dia
â”‚   â”œâ”€â”€ Omitida
â”‚   â”‚   â”œâ”€â”€ audio omitted
â”‚   â”‚   â”œâ”€â”€ image omitted
â”‚   â”‚   â”œâ”€â”€ video omitted
â”‚   â”‚   â”œâ”€â”€ sticker omitted
â”‚   â”‚   â”œâ”€â”€ GIF omitted
â”‚   â”‚   â””â”€â”€ document omitted
â”‚   â”‚
â”‚   â””â”€â”€ Anexada
â”‚       â”œâ”€â”€ Ãudio (.opus, .mp3)
â”‚       â”œâ”€â”€ VÃ­deo (.mp4)
â”‚       â”œâ”€â”€ Imagem (.jpg, .png)
â”‚       â””â”€â”€ Documento (.pdf, .docx)
â”‚
â””â”€â”€â”€â”€â”€â”€ Especial
        â”œâ”€â”€ Editada (<This message was edited>)
        â”œâ”€â”€ Deletada (This message was deleted)
        â””â”€â”€ Chamada (Missed/Voice/Video call)
```
:::
::::

------------------------------------------------------------------------

# Resumo das Descobertas

::: panel-tabset
## DecisÃµes para Data Cleaning

| Descoberta | DecisÃ£o |
|-----------------------------------------|-------------------------------|
| Caractere U+200E em \~50% das linhas | Remover todas ocorrÃªncias |
| Timestamps vazios ocasionais | Remover linhas |
| Linhas completamente vazias | Remover |
| EspaÃ§os mÃºltiplos | Normalizar para espaÃ§o Ãºnico |
| Nomes dos participantes | Anonimizar (P1, P2) |
| Formato timestamp `[DD/MM/YY, HH:MM:SS]` | Simplificar para `DD/MM/YY HH:MM:SS` |

## DecisÃµes para Data Wrangling

| Descoberta | DecisÃ£o |
|-----------------------------------------|-------------------------------|
| Linhas de continuaÃ§Ã£o (multi-linha) | Agregar ao conteÃºdo da mensagem anterior |
| MÃ­dias omitidas vs anexadas | Classificar em `status_midia` |
| Arquivos fÃ­sicos de mÃ­dia | Vincular pelo nome do arquivo |
| Ãudios e vÃ­deos anexados | Transcrever via API (Groq/Whisper) |

## PadrÃµes Regex NecessÃ¡rios

``` python
# Timestamp
r'^\[(\d{2}/\d{2}/\d{2}), (\d{2}:\d{2}:\d{2})\]'

# Mensagem completa (apÃ³s otimizaÃ§Ã£o)
r'^(\d{2}/\d{2}/\d{2}) (\d{2}:\d{2}:\d{2}) (.+?): (.*)$'

# MÃ­dia omitida
r'(audio|image|video|sticker|GIF|document) omitted'

# MÃ­dia anexada
r'<attached: (.+?)>'
```
:::

------------------------------------------------------------------------

# PrÃ³ximos Passos

Com o profiling completo, seguimos para:

1.  [**Data Cleaning**](01-data-cleaning.qmd) â€” Implementar limpeza
2.  [**Data Wrangling**](02-data-wrangling.qmd) â€” Parsing e estruturaÃ§Ã£o